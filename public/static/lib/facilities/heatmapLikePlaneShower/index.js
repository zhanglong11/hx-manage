import{triangulation}from"../../util/gemotryUtils";const canvas=document.createElement("canvas");function makePlane(e,t){let a=new THREE.BufferGeometry,i=new Float32Array([0,0,0,e,0,0,e,t,0,0,t,0]),r=new Uint16Array([3,0,1,3,1,2]);return a.addAttribute("position",new THREE.BufferAttribute(i,3)),a.addAttribute("index",new THREE.BufferAttribute(r,1)),a.addAttribute("uv",new THREE.BufferAttribute(new Float32Array([0,0,1,0,1,1,0,1]),2)),a}export function makePlaneFromPloygon(e){let t=e.map(e=>e.x),a=e.map(e=>e.y),i=Math.min.apply(Math,t),r=Math.max.apply(Math,a),l=Math.min.apply(Math,a),n=Math.max.apply(Math,a),s=new THREE.Vector2(i,l),o=new THREE.Vector2(r,n),h=Math.abs(r-i),p=Math.abs(n-l),m=new THREE.BufferGeometry,{position:u,uvs:v}=e.reduce((e,t)=>{let{position:a,uvs:i}=e;return{position:[...a,t.x,t.y,0],uvs:[...i,t.x/h,t.y/p]}},{position:[],uvs:[]}),d=triangulation(e);return m.addAttribute("position",new THREE.BufferAttribute(new Float32Array(u),3)),m.addAttribute("uv",new THREE.BufferAttribute(new Float32Array(v),2)),m.addAttribute("index",new THREE.BufferAttribute(new Uint16Array(d),1)),{geometry:m,area:{min:s,max:o},boxSize:{width:h,height:p}}}function bakeHeatmapData(e){let t=e.length,a=e[0].pos.distanceTo(e[t-1].pos),i=[],r=e[0].pos;for(let l=0;l<t;l++){let t=e[l],n=r.distanceTo(t.pos)/a,s=t.value;i.push({percent:n,value:s})}return i}function getPixelLineNumber(e,t){return Math.floor(e/t)}export function makeHeapmapTexture(e,t,a,i){let r=2*Math.floor(e),l=2*Math.floor(t);canvas.width=r,canvas.height=l;let{minValue:n,maxValue:s}=i;const o=canvas.getContext("2d");o.clearRect(0,0,r,l);let h=o.getImageData(0,0,r,l),p=h.data,m=bakeHeatmapData(a);console.log(m);let u=0,v=1,d=m[u].value,c=m[v].value,_=m[u].percent,y=m[v].percent;for(let e=0;e<p.length;e+=4*r){let t=getPixelLineNumber(e/4,r)/l;console.log(t);let a,i=(t-_)/(y-_),o=(1-i)*d+i*c;if(o>=s)a=[255,0,0];else if(o<=n)a=[0,255,0];else{let e=(o-n)/(s-n);a=[255*(1-e),255*e,0]}let[h,f,w]=a;for(let t=0;t<4*r;t+=4){let a=e+t,i=a+1,r=i+1,l=r+1;p[a]=h,p[i]=f,p[r]=w,p[l]=200}t>=y&&(u=v,v+=1,d=m[u].value,c=m[v].value,_=m[u].percent,y=m[v].percent)}o.putImageData(h,0,0),console.log(canvas.toDataURL());let f=THREE.ImageUtils.loadTexture(canvas.toDataURL());return f.minFilter=THREE.NearestFilter,f}class HeatmapPlane{constructor(e,t,a,i){this._points=e,this._options=i,this._value=t;let{geometry:r,boxSize:l}=makePlaneFromPloygon(e);console.log(l),this._geometry=r;let n=makeHeapmapTexture(l.width,l.height,t,i);this._material=new THREE.MeshBasicMaterial({map:n,transparent:!0,depthWrite:!1,depthTest:!0}),this._mesh=new THREE.Mesh(this._geometry,this._material),this._mesh.position.setZ(a)}setPosition(e){this._mesh.position.set(e.x,e.y,1)}updateValue(e){this._value=e;let t=makeHeapmapTexture(this._width,this._height,e,this._options);this._material.map=t,this._material.needsUpdate=!0}}export default class HeatmapLikePlaneManager{constructor(e,t){this.viewer=e,this._defaultHeatmapOption=t,this._planes={},this._overlayName="heatmapOverlay",this._overlayCreated=!1}add(e,t,a,i=1,r=this._defaultHeatmapOption){this._overlayCreated||(this.viewer.impl.createOverlayScene(this._overlayName),this._overlayCreated=!0);let l=new HeatmapPlane(t,a,i,r);this._planes[e]&&this.remove(e),this._planes[e]=l,this.viewer.impl.addOverlay(this._overlayName,l._mesh),this.viewer.impl.invalidate(!1,!1,!0)}get(e){return this._planes[e]}remove(e){if(!this._planes[e])return!1;let t=this._planes[e];return this.viewer.impl.removeOverlay(this._overlayName,t._mesh),delete this._planes[e],this.viewer.impl.invalidate(!1,!1,!0),!0}removeAll(){let e=Object.keys(this._planes);for(let t of e){let e=this._planes[t];this.viewer.impl.removeOverlay(this._overlayName,e._mesh),delete this._planes[t]}return this.viewer.impl.invalidate(!1,!1,!0),!0}}